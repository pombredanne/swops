--- database.c	2012-09-06 14:12:12.000000000 +0000
+++ database.c	2012-09-06 14:04:40.000000000 +0000
@@ -60,6 +60,59 @@
 static void free_orphan(orphan *o);
 
 void
+scan_directory(char *dirname, const char *base, cron_db *old_db, cron_db *new_db)
+{ 
+	DIR     	*dir;
+	DIR_T   	*dp;
+	struct stat	statbuf;
+
+	/* we used to keep this dir open all the time, for the sake of
+	 * efficiency.  however, we need to close it in every fork, and
+	 * we fork a lot more often than the mtime of the dir changes.
+	 */
+	if (!(dir = opendir(dirname))) {
+		log_it("CRON", getpid(), "OPENDIR FAILED", dirname);
+	}
+
+	while (dir != NULL && NULL != (dp = readdir(dir))) {
+		char	fname[MAXNAMLEN+1],
+			tabname[PATH_MAX+1];
+
+		/* avoid file names beginning with ".".  this is good
+		 * because we would otherwise waste two guaranteed calls
+		 * to getpwnam() for . and .., and also because user names
+		 * starting with a period are just too nasty to consider.
+		 */
+		if (dp->d_name[0] == '.')
+			continue;
+
+
+		(void) strcpy(fname, dp->d_name);
+		strcpy(tabname, dirname);
+		strncat(tabname, "/", sizeof tabname);
+		strncat(tabname, fname, sizeof tabname);
+
+                if (dp->d_type == DT_DIR) {
+			char	newbase[PATH_MAX+1];
+			/* By convention, base ends with '/' except for the initial call
+			 * which is "". */
+			strcpy(newbase, base);
+			strncat(newbase, fname, sizeof newbase);
+			strncat(newbase, "/", sizeof newbase);
+                        scan_directory(tabname, newbase, old_db, new_db);
+                } else {
+		        char user[PATH_MAX+1];
+		        strcpy(user, base);
+			strncat(user, fname, sizeof user);
+                        process_crontab(user, tabname, tabname,
+				&statbuf, new_db, old_db);
+		}
+	}
+	if (dir)
+		closedir(dir);
+}
+
+void
 load_database(old_db)
 	cron_db		*old_db;
 {
@@ -220,35 +273,8 @@
 	if (dir)
 		closedir(dir);
 #endif
+        scan_directory(SPOOL_DIR, "", old_db, &new_db);
 
-	/* we used to keep this dir open all the time, for the sake of
-	 * efficiency.  however, we need to close it in every fork, and
-	 * we fork a lot more often than the mtime of the dir changes.
-	 */
-	if (!(dir = opendir(SPOOL_DIR))) {
-		log_it("CRON", getpid(), "OPENDIR FAILED", SPOOL_DIR);
-	}
-
-	while (dir != NULL && NULL != (dp = readdir(dir))) {
-		char	fname[MAXNAMLEN+1],
-			tabname[PATH_MAX+1];
-
-		/* avoid file names beginning with ".".  this is good
-		 * because we would otherwise waste two guaranteed calls
-		 * to getpwnam() for . and .., and also because user names
-		 * starting with a period are just too nasty to consider.
-		 */
-		if (dp->d_name[0] == '.')
-			continue;
-
-		(void) strcpy(fname, dp->d_name);
-		snprintf(tabname, PATH_MAX+1, CRON_TAB(fname));
-
-		process_crontab(fname, fname, tabname,
-				&statbuf, &new_db, old_db);
-	}
-	if (dir)
-		closedir(dir);
 
 	/* if we don't do this, then when our children eventually call
 	 * getpwnam() in do_command.c's child_process to verify MAILTO=,
@@ -272,7 +298,6 @@
 	Debug(DLOAD, ("load_database is done\n"))
 }
 
-
 void
 link_user(db, u)
 	cron_db	*db;
@@ -323,7 +348,7 @@
 static void
 process_crontab(uname, fname, tabname, statbuf, new_db, old_db)
 	char		*uname;
-	char		*fname;
+	char		*fname;  /* Just for logging */
 	char		*tabname;
 	struct stat	*statbuf;
 	cron_db		*new_db;
